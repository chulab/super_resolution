"""Methods to simulate US image formation."""

import tensorflow as tf
from typing import Optional, Tuple

from simulation import complex_convolution


def observe(
    state: tf.Tensor,
    psf_lateral: tf.Tensor,
    psf_axial: tf.Tensor,
    lateral_spec: Optional[Tuple] = None,
    axial_spec: Optional[Tuple] = None,
) -> tf.Tensor:
  """Simulates an observation of `state` using the convolution method.

  This function simulates and US obersvation by a device which is parameterized
  by an axial and lateral PSF. This method is verified in:
    `Gao et al., Jan. (2009). A Fast Convolution-Based Methodology to
    Simulate 2-D/3-D Cardiac Ultrasound Images.`

  This function performs:
    `psf_axial X psf_lateral X state`
  where `X` represents convolution. The convolutions take place along the last
  two axes (see signature for `state`) for axial and lateral psfs respectively.

  If `psf_lateral` and `psf_axial` are complex, then this function generates
  the RF signal generated by imaging state including any interference effects.

  Args:
    state: `tf.Tensor` of shape `batch_dimensions + [height, width]`.
    psf_lateral: 1D `tf.Tensor` representing lateral PSF of imaging device.
    psf_axial: 1D `tf.Tensor` representing axial PSF opf imaging device.
    lateral_spec: Optional parameters to modify convolution in lateral
      direction. See `complex_convolution` for options.
    axial_spec: Optional parameters to modify convolution in axial
      direction. See `complex_convolution` for options.

  Returns:
    A `tf.Tensor` of the same shape as `state` corresponding to the signal
    generated by the simulated imaging of `state`.

  Raises:
    ValueError: If any argument has the incorrect dimensions.
  """
  if state.shape.ndims < 2:
    raise ValueError("State must be at least 2D (`[width, height]`) but got {}"
                     "".format(state.shape))
  if any(psf.shape.ndims > 1 for psf in [psf_lateral, psf_axial]):
    raise ValueError("Both PSF's must be 1D but got {}".format(
      [psf_lateral, psf_axial]))

  # First convolve with `psf_lateral`.
  state = complex_convolution.convolve_complex_1d(state, psf_lateral, padding="SAME")

  axes = [axis for axis in range(state.shape.ndims)]
  last_axes_permute = axes[:-2] + [axes[-1]] + [axes [-2]]
  print(last_axes_permute)

  # Swap `height` and `width` dimensions. Now has shape `[batch, angle, width, height]`
  state = tf.transpose(state, last_axes_permute)

  # Convolve with `psf_lateral`.
  state = complex_convolution.convolve_complex_1d(state, psf_axial, padding="SAME")

  # Return `height` and `width` axes to original locations.
  state = tf.transpose(state, last_axes_permute)

  # Return real values.
  return tf.abs(state)

